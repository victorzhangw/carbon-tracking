# Emotion-Analysis 多輪對話改善方案

## 🎯 問題分析

### 當前問題

從你提供的對話記錄可以看出：

```
🤖 嗯～下午天氣真不錯呢！很適合逛街購物喔，要不要出去走走呀？
👤 可以啊出去走走也好
🤖 聽起來你心情不錯耶～願意出去走走真的很棒！...
👤 那你可以推薦啊
🤖 哈囉！當然可以幫你推薦啊～不過想先了解一下，你現在是想找人聊聊心事...
```

**問題點**:

- AI 說「哈囉！」表示它忘記了之前的對話
- AI 問「想找人聊聊心事還是需要資源」，但用戶已經在討論出去走走的話題
- 每輪對話都是獨立的，沒有上下文記憶

### 根本原因

1. **前端沒有維護對話歷史**: 每次請求都只發送當前的語音文字
2. **後端沒有接收對話上下文**: `process_audio` 只處理單次輸入
3. **使用舊版 API**: 調用 `analyze_and_respond()` 而非 `analyze_and_respond_with_context()`

## ✅ 改善方案

### 方案架構

```
前端 (emotion_analysis.html)
  ↓
維護對話歷史陣列 (conversationHistory)
  ↓
每次錄音後，將對話加入歷史
  ↓
發送請求時，附帶對話上下文
  ↓
後端 (routes/main.py)
  ↓
接收對話上下文參數
  ↓
調用 analyze_and_respond_with_context()
  ↓
返回帶上下文的回應
```

## 🔧 實現步驟

### 步驟 1: 修改後端 API

**文件**: `routes/main.py`

新增支援對話上下文的 API 端點：

```python
@main.route('/process_audio_with_context', methods=['POST'])
def process_audio_with_context():
    """處理音頻並支援多輪對話上下文"""
    try:
        if 'file' not in request.files:
            return jsonify({"error": "未上傳檔案"}), 400

        file = request.files['file']
        audio_data = file.read()

        # 獲取對話上下文（從表單數據）
        conversation_context_json = request.form.get('conversation_context', '[]')
        conversation_context = json.loads(conversation_context_json)

        # 獲取對話輪次
        conversation_round = int(request.form.get('conversation_round', 0))

        # 導入服務
        from services.speech import transcribe_audio
        from services.ai import analyze_and_respond_with_context
        from services.tts import f5_tts
        import threading
        import uuid

        # 語音轉文字
        transcript = transcribe_audio(audio_data)
        if not transcript:
            return jsonify({"error": "無法轉錄音頻"}), 500

        # 使用帶上下文的 AI 分析
        analysis_result = analyze_and_respond_with_context(
            user_input=transcript,
            conversation_context=conversation_context,
            response_style='friendly',
            conversation_mode='continuous',
            conversation_round=conversation_round
        )

        response_text = analysis_result.get("response", "")

        # 生成唯一的任務 ID
        task_id = str(uuid.uuid4())

        # 異步生成 TTS
        def generate_tts_async():
            try:
                print(f"🎵 開始異步生成 TTS (任務 {task_id[:8]}...)")
                output_file = f5_tts(response_text)
                if output_file:
                    filename = os.path.basename(output_file)
                    audio_url = f"/genvoice/{filename}"
                    if not hasattr(main, 'tts_cache'):
                        main.tts_cache = {}
                    main.tts_cache[task_id] = audio_url
                    print(f"✅ TTS 異步生成成功: {audio_url}")
            except Exception as e:
                print(f"❌ TTS 異步生成錯誤: {e}")

        if response_text:
            thread = threading.Thread(target=generate_tts_async, daemon=True)
            thread.start()

        return jsonify({
            "transcript": transcript,
            "sentiment": analysis_result.get("sentiment", "neutral"),
            "response": response_text,
            "confidence": analysis_result.get("confidence", 0.8),
            "audio_url": None,
            "task_id": task_id,
            "tts_status": "generating",
            "conversation_round": conversation_round + 1
        })

    except Exception as e:
        print(f"處理音頻錯誤: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({"error": f"處理音頻時發生錯誤: {str(e)}"}), 500
```

### 步驟 2: 修改前端邏輯

**文件**: `templates/emotion_analysis.html`

在 JavaScript 部分添加對話歷史管理：

```javascript
// 對話歷史管理
let conversationHistory = [];
let conversationRound = 0;

// 添加對話到歷史
function addToConversationHistory(role, content) {
  conversationHistory.push({
    role: role, // 'user' 或 'assistant'
    content: content,
  });

  // 限制歷史長度（保留最近 10 條）
  if (conversationHistory.length > 10) {
    conversationHistory = conversationHistory.slice(-10);
  }

  console.log(
    `📝 對話歷史更新 (${conversationHistory.length} 條):`,
    conversationHistory
  );
}

// 清空對話歷史
function clearConversationHistory() {
  conversationHistory = [];
  conversationRound = 0;
  console.log("🗑️ 對話歷史已清空");
}

// 修改 stopRecordBtn 事件監聽器
stopRecordBtn.addEventListener("click", () => {
  // ... 前面的代碼保持不變

  mediaRecorder.onstop = async () => {
    const audioBlob = new Blob(audioChunks, { type: "audio/wav" });
    const formData = new FormData();
    formData.append("file", audioBlob, "recording.wav");

    // ✅ 添加對話上下文
    formData.append(
      "conversation_context",
      JSON.stringify(conversationHistory)
    );
    formData.append("conversation_round", conversationRound);

    try {
      // ✅ 使用新的 API 端點
      const response = await fetch("/process_audio_with_context", {
        method: "POST",
        body: formData,
      });

      const result = await response.json();

      if (response.ok) {
        // 1. 顯示用戶訊息
        if (result.transcript) {
          addUserMessage(result.transcript);
          // ✅ 添加到對話歷史
          addToConversationHistory("user", result.transcript);
        }

        // 2. 顯示 AI 思考
        addTypingIndicator();

        // 3. 延遲後顯示 AI 回應
        setTimeout(async () => {
          removeTypingIndicator();

          const emotionInfo = result.sentiment
            ? getEmotionInfo(result.sentiment)
            : null;

          const responseText = result.response || "抱歉，我現在無法回應。";

          // 顯示 AI 回應（打字機效果）
          await addAIMessage(responseText, emotionInfo, true);

          // ✅ 添加到對話歷史
          addToConversationHistory("assistant", responseText);

          // ✅ 更新對話輪次
          conversationRound =
            result.conversation_round || conversationRound + 1;

          console.log(`🔄 對話輪次: ${conversationRound}`);

          // 記錄到評分系統
          if (scoreManager) {
            scoreManager.recordConversation(
              "user",
              result.transcript,
              result.sentiment,
              0.8
            );
            scoreManager.recordConversation(
              "ai",
              responseText,
              result.sentiment,
              0.9
            );
          }

          updateStatus("✅ 文字顯示完成", false);

          // 4. 處理 TTS
          if (result.tts_status === "generating" && result.task_id) {
            updateStatus("🎵 正在生成語音...", true);

            const checkTTSStatus = async () => {
              try {
                const ttsResponse = await fetch(
                  `/api/check-tts/${result.task_id}`
                );
                const ttsResult = await ttsResponse.json();

                if (ttsResult.status === "ready" && ttsResult.audio_url) {
                  playAudio(ttsResult.audio_url);
                } else {
                  setTimeout(checkTTSStatus, 1000);
                }
              } catch (error) {
                console.error("檢查 TTS 狀態失敗:", error);
                updateStatus("⚠️ 語音生成失敗", false);
              }
            };

            setTimeout(checkTTSStatus, 3000);
          }
        }, 1000);
      } else {
        throw new Error(result.error || "處理音頻時發生錯誤");
      }
    } catch (error) {
      console.error("音頻處理失敗：", error);
      removeTypingIndicator();
      addAIMessage("抱歉，處理您的訊息時發生錯誤，請稍後再試。");
      updateStatus("❌ 處理失敗", false);
    }

    audioChunks = [];
  };
});

// 添加「結束對話」按鈕的處理
const endSessionBtn = document.getElementById("endSession");
if (endSessionBtn) {
  endSessionBtn.addEventListener("click", () => {
    if (confirm("確定要結束對話嗎？對話歷史將被清空。")) {
      clearConversationHistory();

      // 顯示系統訊息
      const systemMsg = document.createElement("div");
      systemMsg.className = "message system";
      systemMsg.innerHTML = `
        <div class="message-content">
          <div class="message-bubble" style="background: #f8f9fa; color: #666; text-align: center;">
            對話已結束，歷史記錄已清空
          </div>
        </div>
      `;
      chatMessages.appendChild(systemMsg);
      chatMessages.scrollTop = chatMessages.scrollHeight;

      updateStatus("對話已結束，可以開始新的對話", false);
    }
  });
}
```

### 步驟 3: 添加對話管理 UI

在 HTML 中添加對話管理按鈕：

```html
<div class="control-panel">
  <!-- 現有的錄音控制 -->
  <div>
    <div class="panel-title">錄音控制</div>
    <div class="button-group">
      <button id="startRecord" class="btn btn-primary">🎤 開始錄音</button>
      <button id="stopRecord" class="btn btn-danger" disabled>
        ⏹️ 停止錄音
      </button>
    </div>
  </div>

  <!-- ✅ 新增：對話管理 -->
  <div>
    <div class="panel-title">對話管理</div>
    <div class="conversation-info">
      <div class="info-item">
        <span class="info-label">對話輪次:</span>
        <span class="info-value" id="conversationRoundDisplay">0</span>
      </div>
      <div class="info-item">
        <span class="info-label">歷史記錄:</span>
        <span class="info-value" id="conversationCountDisplay">0 條</span>
      </div>
    </div>
    <button id="clearHistory" class="btn btn-secondary">🗑️ 清空歷史</button>
  </div>

  <!-- 現有的波形和狀態 -->
  <!-- ... -->
</div>
```

添加對應的 CSS：

```css
.conversation-info {
  background: #f8f9fa;
  border-radius: 6px;
  padding: 12px;
  margin-bottom: 12px;
}

.info-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 6px 0;
  font-size: 14px;
}

.info-label {
  color: #666;
}

.info-value {
  font-weight: 600;
  color: #333;
}

.btn-secondary {
  background: #6c757d;
  color: white;
  width: 100%;
}

.btn-secondary:hover:not(:disabled) {
  background: #5a6268;
  transform: translateY(-1px);
}
```

## 📊 效果對比

### 改善前

```
👤 可以啊出去走走也好
🤖 聽起來你心情不錯耶～願意出去走走真的很棒！
👤 那你可以推薦啊
🤖 哈囉！當然可以幫你推薦啊～不過想先了解一下... ❌ 忘記之前的對話
```

### 改善後

```
👤 可以啊出去走走也好
🤖 聽起來你心情不錯耶～願意出去走走真的很棒！
👤 那你可以推薦啊
🤖 當然可以！既然你想出去走走，我推薦幾個台中不錯的地方... ✅ 記得之前討論的內容
```

## 🎯 功能特點

### 1. 對話上下文記憶

- 保留最近 10 條對話記錄
- AI 可以參考之前的對話內容
- 話題連貫，不會重複問候

### 2. 對話輪次追蹤

- 顯示當前對話輪次
- AI 根據輪次調整回應策略
- 第 1 輪：友好打招呼
- 第 2-3 輪：深入了解
- 第 4+ 輪：提供具體建議

### 3. 歷史管理

- 顯示對話歷史數量
- 可手動清空歷史
- 結束對話時自動清空

### 4. 智能回應

- 根據上下文調整語氣
- 避免重複相同的問題
- 提供更相關的建議

## 🔍 測試場景

### 場景 1: 連續對話

```
輪次 1:
👤 今天天氣真好
🤖 是啊！今天天氣真不錯呢～你有什麼計劃嗎？

輪次 2:
👤 想出去走走
🤖 那很棒啊！既然天氣這麼好，出去走走很舒服的。你想去哪裡呢？

輪次 3:
👤 不知道去哪
🤖 嗯～那我推薦幾個地方給你參考！像是公園散步、逛逛商場，或是去咖啡廳坐坐都不錯喔！
```

### 場景 2: 話題轉換

```
輪次 1:
👤 最近心情不太好
🤖 哎呀～聽起來你最近遇到一些困擾呢。願意跟我聊聊發生什麼事嗎？

輪次 2:
👤 工作壓力很大
🤖 工作壓力大真的很辛苦呢。可以跟我說說是什麼樣的壓力嗎？這樣我比較能幫你想想辦法。

輪次 3:
👤 算了不想說了
🤖 沒關係的，不想說也可以。有時候暫時不談也是一種調適方式。要不要聊點輕鬆的話題呢？
```

## 📝 實施檢查清單

- [ ] 修改 `routes/main.py`，添加 `process_audio_with_context` 端點
- [ ] 修改 `templates/emotion_analysis.html`，添加對話歷史管理
- [ ] 添加對話管理 UI（輪次顯示、清空按鈕）
- [ ] 測試多輪對話功能
- [ ] 測試歷史清空功能
- [ ] 測試對話輪次追蹤
- [ ] 驗證 AI 回應的連貫性

## 🚀 部署步驟

1. **備份現有文件**
2. **修改後端代碼**
3. **修改前端代碼**
4. **重啟 Flask 應用**
5. **測試功能**

## 💡 進階優化建議

### 優化 1: 對話摘要

當對話歷史過長時，使用 AI 生成摘要：

```python
def summarize_conversation(conversation_history):
    """生成對話摘要"""
    # 使用 AI 總結對話要點
    # 減少上下文長度，提高效率
```

### 優化 2: 情緒追蹤

追蹤用戶情緒變化：

```javascript
let emotionHistory = [];
function trackEmotion(sentiment) {
  emotionHistory.push({
    sentiment: sentiment,
    timestamp: new Date(),
  });
}
```

### 優化 3: 話題檢測

自動檢測話題轉換：

```python
def detect_topic_change(current_input, conversation_context):
    """檢測話題是否改變"""
    # 使用 NLP 技術檢測話題轉換
    # 適時清空不相關的歷史
```

## 🎉 預期效果

實施後，emotion-analysis 將具備：

- ✅ 完整的多輪對話能力
- ✅ 上下文記憶功能
- ✅ 連貫的對話體驗
- ✅ 智能的回應策略
- ✅ 清晰的對話管理

用戶將體驗到更自然、更智能的對話互動！
