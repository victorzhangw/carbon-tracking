# Flask-AICares 技術細節與最佳實踐

## 一、數據庫設計

### 1.1 核心數據表結構

#### 用戶認證系統

**users 表**
```sql
CREATE TABLE users (
    id TEXT PRIMARY KEY,              -- UUID
    username TEXT NOT NULL UNIQUE,
    email TEXT NOT NULL UNIQUE,
    password_hash TEXT NOT NULL,      -- bcrypt加密
    full_name TEXT,
    is_active BOOLEAN DEFAULT 1,
    created_at TEXT,
    updated_at TEXT
)
```

**roles 表**
```sql
CREATE TABLE roles (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,        -- admin/manager/staff/viewer
    description TEXT,
    created_at TEXT
)
```

**permissions 表**
```sql
CREATE TABLE permissions (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,        -- perm_staff_read等
    description TEXT,
    resource TEXT,                     -- staff/audio/user等
    action TEXT,                       -- read/create/update/delete
    created_at TEXT
)
```

**關聯表**
```sql
-- 多對多：用戶-角色
CREATE TABLE user_roles (
    user_id TEXT,
    role_id TEXT,
    assigned_at TEXT,
    PRIMARY KEY (user_id, role_id),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE
)

-- 多對多：角色-權限
CREATE TABLE role_permissions (
    role_id TEXT,
    permission_id TEXT,
    assigned_at TEXT,
    PRIMARY KEY (role_id, permission_id),
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
    FOREIGN KEY (permission_id) REFERENCES permissions(id) ON DELETE CASCADE
)
```

#### 業務數據表

**staff 表**
```sql
CREATE TABLE staff (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    code TEXT NOT NULL UNIQUE,        -- 員工代號
    phone TEXT,
    email TEXT,
    status TEXT DEFAULT 'active',
    description TEXT,
    created_at TEXT,
    updated_at TEXT
)
```

**audio 表**
```sql
CREATE TABLE audio (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    staff_id TEXT,                    -- FK to staff.id
    file_path TEXT NOT NULL,
    duration INTEGER,                 -- 秒
    file_size TEXT,                   -- 格式化大小
    status TEXT DEFAULT 'active',
    description TEXT,
    created_at TEXT,
    updated_at TEXT,
    FOREIGN KEY (staff_id) REFERENCES staff(id)
)
```

#### 語音模型表

**voice_models 表**
```sql
CREATE TABLE voice_models (
    id TEXT PRIMARY KEY,
    staff_code TEXT,
    original_audio_path TEXT,
    processed_audio_path TEXT,
    reference_text TEXT,
    model_status TEXT,               -- processing/ready/error
    quality_score REAL,
    created_at TEXT,
    updated_at TEXT
)
```

**voice_generations 表**
```sql
CREATE TABLE voice_generations (
    id TEXT PRIMARY KEY,
    staff_code TEXT,
    input_text TEXT,
    generated_audio_path TEXT,
    sentiment TEXT,
    generation_time TEXT
)
```

#### 碳排放追蹤表

**visit_records 表**
```sql
CREATE TABLE visit_records (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    visit_date DATE NOT NULL,
    social_worker_id TEXT NOT NULL,
    social_worker_name TEXT NOT NULL,
    elder_id TEXT NOT NULL,
    elder_name TEXT,
    visit_type TEXT NOT NULL,
    transport_type TEXT NOT NULL,
    distance REAL NOT NULL,
    travel_time INTEGER,
    start_location TEXT,
    end_location TEXT,
    carbon_emission REAL,             -- 自動計算
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
```

**emission_coefficients 表**
```sql
CREATE TABLE emission_coefficients (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    transport_type TEXT UNIQUE NOT NULL,
    coefficient REAL NOT NULL,        -- kg CO2e/km
    unit TEXT NOT NULL,
    source TEXT,                      -- 資料來源
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)

-- 預設數據
INSERT INTO emission_coefficients VALUES
('機車', 0.0695, 'kg CO2e/km', '環保署排放係數管理表6.0.4版'),
('汽車', 0.1850, 'kg CO2e/km', '環保署排放係數管理表6.0.4版'),
('大眾運輸', 0.0295, 'kg CO2e/km', '環保署排放係數管理表6.0.4版')
```

### 1.2 數據庫操作最佳實踐

#### 分頁查詢
```python
def get_paginated_results(query, params, page, size):
    """
    通用分頁函數
    """
    # 1. 計算總數
    count_query = f"SELECT COUNT(*) as count FROM ({query})"
    total = cursor.execute(count_query, params).fetchone()['count']
    
    # 2. 分頁查詢
    offset = (page - 1) * size
    paginated_query = f"{query} LIMIT ? OFFSET ?"
    items = cursor.execute(paginated_query, params + [size, offset]).fetchall()
    
    # 3. 返回結構化數據
    return {
        'items': items,
        'total': total,
        'page': page,
        'size': size,
        'total_pages': (total + size - 1) // size
    }
```

#### 事務處理
```python
def update_staff_with_files(staff_id, data):
    """
    更新員工信息並移動關聯文件
    """
    conn = sqlite3.connect(DATABASE)
    cursor = conn.cursor()
    
    try:
        # 1. 獲取舊代號
        old_code = cursor.execute(
            'SELECT code FROM staff WHERE id = ?', 
            [staff_id]
        ).fetchone()[0]
        
        # 2. 更新數據庫
        cursor.execute(
            'UPDATE staff SET code = ?, name = ?, ... WHERE id = ?',
            [new_code, name, ..., staff_id]
        )
        
        # 3. 移動文件
        move_staff_files(old_code, new_code)
        
        # 4. 更新音頻路徑
        cursor.execute(
            'UPDATE audio SET file_path = ? WHERE staff_id = ?',
            [new_path, staff_id]
        )
        
        # 5. 提交事務
        conn.commit()
        return True
        
    except Exception as e:
        # 6. 回滾
        conn.rollback()
        raise e
    finally:
        conn.close()
```

#### 軟刪除策略
```python
def delete_staff(staff_id):
    """
    刪除員工時處理關聯數據
    """
    # 1. 檢查關聯的音頻記錄
    audio_count = cursor.execute(
        'SELECT COUNT(*) FROM audio WHERE staff_id = ?',
        [staff_id]
    ).fetchone()[0]
    
    if audio_count > 0:
        # 2. 將關聯記錄的外鍵設為NULL（軟刪除）
        cursor.execute(
            'UPDATE audio SET staff_id = NULL WHERE staff_id = ?',
            [staff_id]
        )
    
    # 3. 刪除員工記錄
    cursor.execute('DELETE FROM staff WHERE id = ?', [staff_id])
    
    conn.commit()
```

---

## 二、API設計規範

### 2.1 RESTful API結構

#### 資源路由設計
```python
# 客服專員資源
GET    /api/staff           # 獲取列表
GET    /api/staff/:id       # 獲取單個
POST   /api/staff           # 創建
PUT    /api/staff/:id       # 更新
DELETE /api/staff/:id       # 刪除

# 音頻資源
GET    /api/audio           # 獲取列表
GET    /api/audio/:id       # 獲取單個
POST   /api/audio/upload    # 上傳
PUT    /api/audio/:id       # 更新
DELETE /api/audio/:id       # 刪除
GET    /api/audio/stream/:id    # 串流
GET    /api/audio/download/:id  # 下載

# 語音克隆
POST   /voice_clone/upload_voice_sample      # 上傳樣本
POST   /voice_clone/generate_response_voice  # 生成語音
GET    /voice_clone/voice_models             # 模型列表
GET    /voice_clone/voice_model/:code        # 模型信息

# ASR
POST   /api/asr/recognize                   # 識別
POST   /api/asr/batch-recognize             # 批次識別
GET    /api/asr/status                      # 狀態
```

#### 統一響應格式
```python
# 成功響應
{
    "success": true,
    "data": {...} or [...],
    "message": "操作成功"
}

# 錯誤響應
{
    "success": false,
    "error": "錯誤描述",
    "code": "ERROR_CODE"
}

# 分頁響應
{
    "items": [...],
    "total": 100,
    "page": 1,
    "size": 10,
    "total_pages": 10
}
```

### 2.2 錯誤處理模式

#### 統一錯誤處理
```python
@staff_bp.route('/<staff_id>', methods=['GET'])
def get_staff(staff_id):
    try:
        # 業務邏輯
        staff = get_staff_by_id(staff_id)
        
        if staff:
            return jsonify(staff), 200
        else:
            return jsonify({"error": "找不到該客服專員"}), 404
            
    except Exception as e:
        print(f"獲取客服專員失敗: {e}")
        return jsonify({"error": "獲取客服專員失敗"}), 500
```

#### 參數驗證
```python
@staff_bp.route('', methods=['POST'])
def add_staff():
    try:
        data = request.json
        
        # 驗證必填字段
        if not data.get('name') or not data.get('code'):
            return jsonify({"error": "姓名和代號為必填項"}), 400
        
        # 驗證格式
        if not validate_email(data.get('email')):
            return jsonify({"error": "郵箱格式不正確"}), 400
        
        # 業務邏輯...
        
    except Exception as e:
        return jsonify({"error": str(e)}), 500
```

---

## 三、認證授權系統

### 3.1 JWT Token管理

#### Token生成
```python
from flask_jwt_extended import create_access_token, create_refresh_token
import datetime

# Access Token (8小時)
access_token = create_access_token(
    identity=user['id'],
    expires_delta=datetime.timedelta(hours=8)
)

# Refresh Token (30天)
refresh_token = create_refresh_token(
    identity=user['id'],
    expires_delta=datetime.timedelta(days=30)
)
```

#### Token驗證
```python
from functools import wraps
from flask_jwt_extended import verify_jwt_in_request, get_jwt_identity

def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        try:
            verify_jwt_in_request()
            return f(*args, **kwargs)
        except Exception as e:
            return jsonify({'error': '無效的認證令牌'}), 401
    return decorated

# 使用
@app.route('/protected')
@token_required
def protected_route():
    user_id = get_jwt_identity()
    ...
```

### 3.2 RBAC權限系統

#### 權限檢查
```python
def permission_required(permission_name):
    def decorator(f):
        @wraps(f)
        def decorated(*args, **kwargs):
            try:
                # 1. 驗證Token
                verify_jwt_in_request()
                user_id = get_jwt_identity()
                
                # 2. 獲取用戶權限
                user_permissions = get_user_permissions(user_id)
                permission_names = [p['name'] for p in user_permissions]
                
                # 3. 檢查權限
                if permission_name not in permission_names:
                    return jsonify({'error': '權限不足'}), 403
                
                return f(*args, **kwargs)
            except Exception as e:
                return jsonify({'error': '認證失敗'}), 401
        return decorated
    return decorator

# 使用
@app.route('/api/staff', methods=['POST'])
@token_required
@permission_required('perm_staff_create')
def create_staff():
    ...
```

#### 角色權限映射
```python
DEFAULT_ROLES = {
    'admin': [
        'perm_staff_read', 'perm_staff_create', 'perm_staff_update', 'perm_staff_delete',
        'perm_audio_read', 'perm_audio_create', 'perm_audio_update', 'perm_audio_delete',
        'perm_user_manage', 'perm_role_manage', 'perm_system_admin'
    ],
    'manager': [
        'perm_staff_read', 'perm_staff_create', 'perm_staff_update',
        'perm_audio_read', 'perm_audio_create', 'perm_audio_update'
    ],
    'staff': [
        'perm_audio_read', 'perm_audio_create'
    ],
    'viewer': [
        'perm_staff_read', 'perm_audio_read'
    ]
}
```

---

## 四、文件處理最佳實踐

### 4.1 安全文件上傳

#### 文件驗證
```python
ALLOWED_EXTENSIONS = {'mp3', 'wav', 'ogg'}

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

# 使用
@app.route('/upload', methods=['POST'])
def upload_file():
    file = request.files['file']
    
    # 1. 檢查文件存在
    if not file or file.filename == '':
        return jsonify({"error": "未選擇檔案"}), 400
    
    # 2. 檢查文件格式
    if not allowed_file(file.filename):
        return jsonify({"error": "不支援的檔案格式"}), 400
    
    # 3. 安全文件名
    filename = secure_filename(file.filename)
    
    # 4. 生成唯一ID
    unique_id = str(uuid.uuid4())
    filename = f"{unique_id}_{filename}"
    
    # 5. 保存文件
    file.save(os.path.join(UPLOAD_DIR, filename))
```

#### 目錄組織
```python
def organize_upload_directory(staff_code):
    """
    按員工代號組織上傳目錄
    """
    staff_dir = os.path.join(AUDIO_UPLOAD_FOLDER, staff_code)
    os.makedirs(staff_dir, exist_ok=True)
    return staff_dir

# 結構
audio_uploads/
├── SW001/
│   ├── uuid1_sample.wav
│   └── uuid2_sample.wav
├── SW002/
│   └── uuid3_sample.wav
└── ...
```

### 4.2 文件服務

#### 安全文件服務
```python
from flask import send_file, send_from_directory

@app.route('/files/<path:filename>')
def serve_file(filename):
    # 1. 安全檢查
    if '..' in filename or filename.startswith('/'):
        return jsonify({"error": "Invalid filename"}), 400
    
    # 2. 檢查文件存在
    file_path = os.path.join(UPLOAD_DIR, filename)
    if not os.path.exists(file_path):
        return jsonify({"error": "File not found"}), 404
    
    # 3. 提供文件
    return send_from_directory(UPLOAD_DIR, filename)
```

#### 音頻串流
```python
@audio_bp.route('/stream/<audio_id>')
def stream_audio(audio_id):
    audio = get_audio_by_id(audio_id)
    
    # 串流模式（不下載）
    return send_file(
        audio['file_path'],
        as_attachment=False,
        mimetype='audio/wav'
    )

@audio_bp.route('/download/<audio_id>')
def download_audio(audio_id):
    audio = get_audio_by_id(audio_id)
    
    # 下載模式
    return send_file(
        audio['file_path'],
        as_attachment=True,
        download_name=f"{audio['name']}.wav"
    )
```

---

## 五、AI服務集成

### 5.1 DeepSeek API調用

#### 配置
```python
from openai import OpenAI

client = OpenAI(
    api_key="sk-...",
    base_url="https://api.siliconflow.cn"
)

MODEL_NAME = "deepseek-ai/DeepSeek-V3"
```

#### 對話生成
```python
def analyze_and_respond_with_context(
    user_input,
    conversation_context=[],
    response_style='friendly',
    conversation_mode='continuous',
    conversation_round=0
):
    # 1. 構建系統提示詞
    system_prompt = build_system_prompt(
        response_style,
        conversation_mode,
        conversation_round
    )
    
    # 2. 構建消息歷史
    messages = [{"role": "system", "content": system_prompt}]
    
    # 3. 添加上下文（最近6條）
    if conversation_context:
        for ctx_msg in conversation_context[-6:]:
            messages.append({
                "role": ctx_msg.get('role', 'user'),
                "content": ctx_msg.get('content', '')
            })
    
    # 4. 添加當前輸入
    user_prompt = build_user_prompt(
        user_input,
        conversation_round,
        len(conversation_context)
    )
    messages.append({"role": "user", "content": user_prompt})
    
    # 5. API調用
    completion = client.chat.completions.create(
        model=MODEL_NAME,
        messages=messages,
        max_tokens=600,
        temperature=get_temperature_by_style(response_style)
    )
    
    # 6. 解析結果
    message_content = completion.choices[0].message.content
    data = json.loads(fix_incomplete_json(message_content))
    
    return {
        "sentiment": data.get('sentiment', '未知'),
        "response": data.get('response', ''),
        "confidence": data.get('confidence', 0.95)
    }
```

#### 提示詞工程
```python
def build_system_prompt(response_style, conversation_mode, conversation_round):
    """
    動態構建系統提示詞
    """
    # 基礎角色設定
    base_prompt = (
        "你是一位專業的社會服務人員，擅長諮商輔導並具有豐富的知識背景。"
        "請以同理心和專業的態度提供建議，特別注意使用適合的中文表達方式，"
        "不能中英文夾雜，以及使用一些語助詞。"
    )
    
    # 風格調整
    style_prompts = {
        'friendly': "語氣要友好親切，像朋友般交談...",
        'professional': "保持專業正式的語調...",
        'casual': "使用輕鬆隨意的語調...",
        'detailed': "提供詳細的解說和分析..."
    }
    
    # 模式調整
    mode_prompts = {
        'continuous': "這是一個連續對話，請參考之前的對話內容...",
        'qa': "這是問答模式，專注於回答用戶的具體問題。",
        'creative': "這是創意模式，可以提供更多創新的想法..."
    }
    
    # 輪次調整
    if conversation_round == 0:
        round_prompt = "這是對話的開始，請友好地打招呼..."
    elif conversation_round < 3:
        round_prompt = "這是對話的前期階段，請深入了解..."
    else:
        round_prompt = "這是深度對話階段，請提供更具體的建議..."
    
    # 組合
    full_prompt = (
        f"{base_prompt}\n"
        f"{style_prompts.get(response_style, style_prompts['friendly'])}\n"
        f"{mode_prompts.get(conversation_mode, mode_prompts['continuous'])}\n"
        f"{round_prompt}\n"
        f"回應字數控制在150-250個中文字之間。"
    )
    
    return full_prompt
```

### 5.2 GPT-SoVITS TTS集成

#### API調用
```python
class GPTSoVITSTTSService:
    def __init__(self):
        self.api_url = "http://127.0.0.1:9880/tts"
        self.output_dir = "genvoice"
    
    def generate_speech(
        self,
        text,
        ref_audio_path=None,
        prompt_text=None,
        text_lang="zh",
        prompt_lang="zh",
        temperature=1.1
    ):
        # 1. 構建請求數據
        payload = {
            "text": text,
            "text_lang": text_lang,
            "ref_audio_path": ref_audio_path or self.default_ref_audio,
            "prompt_lang": prompt_lang,
            "prompt_text": prompt_text or "默認提示文字",
            "batch_size": 20,
            "text_split_method": "cut5",
            "batch_threshold": 0.75,
            "streaming_mode": False,
            "temperature": temperature
        }
        
        # 2. 發送POST請求
        response = requests.post(
            self.api_url,
            headers={'Content-Type': 'application/json'},
            data=json.dumps(payload),
            timeout=120
        )
        
        # 3. 處理響應
        if response.status_code == 200:
            # 保存音頻文件
            timestamp = int(time.time())
            output_filename = f"tts_{timestamp}.wav"
            output_path = os.path.join(self.output_dir, output_filename)
            
            with open(output_path, 'wb') as f:
                f.write(response.content)
            
            return output_path
        else:
            print(f"TTS API錯誤: {response.status_code}")
            return None
```

#### 錯誤處理
```python
try:
    audio_path = gpt_sovits_tts.generate_speech(text, ref_audio, prompt)
    if audio_path:
        return jsonify({"audio_url": f"/genvoice/{os.path.basename(audio_path)}"})
    else:
        return jsonify({"error": "語音生成失敗"}), 500
        
except requests.exceptions.Timeout:
    return jsonify({"error": "TTS請求超時"}), 504
    
except requests.exceptions.ConnectionError:
    return jsonify({"error": "無法連接到TTS服務"}), 503
    
except Exception as e:
    return jsonify({"error": f"TTS生成錯誤: {str(e)}"}), 500
```

---

## 六、性能優化策略

### 6.1 數據庫優化

#### 索引策略
```sql
-- 常用查詢字段
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_staff_code ON staff(code);
CREATE INDEX idx_audio_staff ON audio(staff_id);
CREATE INDEX idx_visit_date ON visit_records(visit_date);
CREATE INDEX idx_visit_worker ON visit_records(social_worker_id);

-- 複合索引
CREATE INDEX idx_visit_date_worker ON visit_records(visit_date, social_worker_id);
```

#### 查詢優化
```python
# 避免 N+1 查詢
# 不好的做法
staff_list = get_all_staff()
for staff in staff_list:
    audio_count = get_audio_count(staff['id'])  # N次查詢

# 好的做法
query = '''
SELECT s.*, COUNT(a.id) as audio_count
FROM staff s
LEFT JOIN audio a ON s.id = a.staff_id
GROUP BY s.id
'''
staff_with_count = execute_query(query)  # 1次查詢
```

### 6.2 快取策略

#### 結果快取
```python
from functools import lru_cache
import time

@lru_cache(maxsize=128)
def get_voice_model_by_staff(staff_code):
    """
    快取語音模型查詢結果
    """
    return database.query_voice_model(staff_code)

# 清除快取
get_voice_model_by_staff.cache_clear()
```

#### 文件快取
```python
# 快取生成的音頻文件
def get_or_generate_audio(text_hash, generate_func):
    cache_path = f"cache/{text_hash}.wav"
    
    if os.path.exists(cache_path):
        return cache_path
    else:
        audio_path = generate_func()
        shutil.copy(audio_path, cache_path)
        return audio_path
```

### 6.3 異步處理

#### AsyncIO集成
```python
import asyncio

async def process_audio_batch(audio_files):
    """
    批次處理音頻
    """
    tasks = [
        process_single_audio(audio)
        for audio in audio_files
    ]
    results = await asyncio.gather(*tasks)
    return results

# 同步調用
def batch_process_endpoint():
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    results = loop.run_until_complete(
        process_audio_batch(audio_files)
    )
    loop.close()
    return results
```

---

## 七、安全最佳實踐

### 7.1 輸入驗證

```python
def validate_input(data, rules):
    """
    通用輸入驗證
    """
    errors = []
    
    for field, rule in rules.items():
        value = data.get(field)
        
        # 必填驗證
        if rule.get('required') and not value:
            errors.append(f"{field} 為必填項")
        
        # 類型驗證
        if value and rule.get('type'):
            if rule['type'] == 'email' and not validate_email(value):
                errors.append(f"{field} 格式不正確")
        
        # 長度驗證
        if value and rule.get('max_length'):
            if len(value) > rule['max_length']:
                errors.append(f"{field} 超過最大長度")
    
    return errors

# 使用
rules = {
    'username': {'required': True, 'max_length': 50},
    'email': {'required': True, 'type': 'email'},
    'code': {'required': True, 'max_length': 20}
}

errors = validate_input(request.json, rules)
if errors:
    return jsonify({"errors": errors}), 400
```

### 7.2 SQL注入防護

```python
# 永遠使用參數化查詢
# 不安全
cursor.execute(f"SELECT * FROM users WHERE username = '{username}'")

# 安全
cursor.execute("SELECT * FROM users WHERE username = ?", [username])
```

### 7.3 密碼安全

```python
import bcrypt

def hash_password(password):
    """
    使用bcrypt加密密碼
    """
    return bcrypt.hashpw(
        password.encode('utf-8'),
        bcrypt.gensalt()
    ).decode('utf-8')

def verify_password(password, password_hash):
    """
    驗證密碼
    """
    return bcrypt.checkpw(
        password.encode('utf-8'),
        password_hash.encode('utf-8')
    )
```

---

## 八、日誌與監控

### 8.1 日誌記錄

```python
import logging

# 配置日誌
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('app.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

# 使用
@app.route('/api/data')
def get_data():
    logger.info(f"Data request from {request.remote_addr}")
    
    try:
        data = fetch_data()
        logger.info(f"Data fetched successfully, count: {len(data)}")
        return jsonify(data)
    except Exception as e:
        logger.error(f"Error fetching data: {e}", exc_info=True)
        return jsonify({"error": "Internal error"}), 500
```

### 8.2 性能監控

```python
import time
from functools import wraps

def measure_time(func):
    """
    測量函數執行時間
    """
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        
        logger.info(
            f"{func.__name__} executed in {end_time - start_time:.2f}s"
        )
        
        return result
    return wrapper

# 使用
@measure_time
def expensive_operation():
    ...
```

---

## 總結

本項目在技術實現上的亮點：

1. **安全性**：完整的RBAC權限系統、JWT認證、密碼加密
2. **可擴展性**：模組化設計、條件式載入、插件化架構
3. **性能**：異步處理、快取策略、索引優化
4. **穩定性**：完善的錯誤處理、日誌記錄、健康檢查
5. **維護性**：清晰的代碼結構、豐富的註釋、統一的編碼規範
